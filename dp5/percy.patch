diff -urN percy++-1.0.0/CMakeLists.txt percy++-1.0.0-dp5/CMakeLists.txt
--- percy++-1.0.0/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ percy++-1.0.0-dp5/CMakeLists.txt	2014-10-16 16:16:18.826925493 +0100
@@ -0,0 +1,16 @@
+project (Percy++)
+
+find_file(NTL_INCLUDE_DIR "NTL/")
+find_path(NTL_INCLUDE_PARENTDIR "NTL/")
+
+include_directories(${NTL_INCLUDE_DIR} ${NTL_INCLUDE_PARENTDIR})
+add_library(percyclient
+	percyclient.cc itclient.cc percyparams.cc itparams.cc recover.cc
+	rsdecoder.cc percyio.cc FXY.cc gf2e.cc subset_iter.cc subset.cc portfolio.cc
+	agparams.cc agclient.cc percystats.cc streams.cc recursiveparams.cc
+	recursiveclient.cc hybridparams.cc nullclient.cc)
+add_library(percyserver
+	percyserver.cc itserver.cc percyparams.cc itparams.cc datastore.cc
+	percyio.cc gf2e.cc agparams.cc agserver.cc percystats.cc
+	streams.cc recursiveparams.cc recursiveserver.cc
+	hybridparams.cc)
diff --git a/Makefile b/Makefile
index 10efaee..6d643c4 100644
--- a/Makefile
+++ b/Makefile
@@ -29,7 +29,7 @@ BIT32_SUPPORT=false
 CXXFLAGS=-Wall -g -O2 -pedantic -I/usr/local/include/NTL #-DVERBOSE -DVERBOSE_DISTRIBUTED -DVERBOSE_RECURSIVE -DVERBOSE_THREADED
 LDLIBS=-lntl -lgmp -pthread -lsocket++ -L/usr/local/lib -lgcrypt
 
-TESTS=findpolys_test rr_test time_findpolys time_findpolys_gf28 time_findpolys_w8 time_findpolys_w16 time_findpolys_w32 testdistserver hybridtest agtest
+TESTS=findpolys_test rr_test time_findpolys time_findpolys_gf28 time_findpolys_w8 time_findpolys_w16 time_findpolys_w32 testdistserver hybridtest agtest cdtest
 
 TARGETS=pirserver agserver hybridserver pirclient agclient hybridclient splitdatabase
 
@@ -44,6 +44,7 @@ SERVER_O=percyserver.o itserver.o percyparams.o itparams.o datastore.o \
 	streams.o recursiveparams.o recursiveserver.o \
 	hybridparams.o
 SRCS=$(subst .o,.cc,$(CLIENT_O) $(SERVER_O) pirclient.o pirserver.o pirclient_ag.o pirserver_ag.o splitdatabase.o percyio.o)
+TESTSRCS=cdtest.cc
 LIBS=libpercyserver.a libpercyclient.a
 
 VERSION=$(shell ./updateheaders.py --version-number)
@@ -72,67 +73,70 @@ libpercyclient.a: $(CLIENT_O)
 tests: $(TESTS)
 
 pirserver: pirserver.o libpercyserver.a
-	g++ -o $@ $^ $(LDLIBS)
+	$(CXX) -o $@ $^ $(LDLIBS)
 
 pirserver_master: pirserver.cc libpercyserver.a
-	g++ $(CXXFLAGS) -DDIST_MASTER -o $@ $^ $(LDLIBS)
+	$(CXX) $(CXXFLAGS) -DDIST_MASTER -o $@ $^ $(LDLIBS)
 
 pirserver_mpi: pirserver.cc mpiserver.o libpercyserver.a
 	mpic++ $(CXXFLAGS) -DMPI_DIST_SERVER -o $@ $^ $(LDLIBS)
 
 pirclient: pirclient.o libpercyclient.a
-	g++ -o $@ $^ $(LDLIBS)
+	$(CXX) -o $@ $^ $(LDLIBS)
 
 agclient: pirclient_ag.o libpercyclient.a
-	g++ -o $@ $^ $(LDLIBS)
+	$(CXX) -o $@ $^ $(LDLIBS)
 
 agserver: pirserver_ag.o libpercyserver.a
-	g++ -o $@ $^ $(LDLIBS)
+	$(CXX) -o $@ $^ $(LDLIBS)
 
 hybridclient: pirclient_hybrid.o libpercyclient.a
-	g++ -o $@ $^ $(LDLIBS)
+	$(CXX) -o $@ $^ $(LDLIBS)
 
 hybridserver: pirserver_hybrid.o libpercyserver.a
-	g++ -o $@ $^ $(LDLIBS)
+	$(CXX) -o $@ $^ $(LDLIBS)
 
 splitdatabase: splitdatabase.o percyio.o gf2e.o
-	g++ -o $@ $^ $(LDLIBS)
+	$(CXX) -o $@ $^ $(LDLIBS)
 
 time_findpolys: rsdecoder.cc FXY.o subset.o subset_iter.o portfolio.o
-	g++ $(CXXFLAGS) -DTIME_FINDPOLYS -o $@ $^ $(LDLIBS) # w128
+	$(CXX) $(CXXFLAGS) -DTIME_FINDPOLYS -o $@ $^ $(LDLIBS) # w128
 
 time_findpolys_gf28: rsdecoder.cc FXY.o subset.o subset_iter.o portfolio.o
-	g++ -static $(CXXFLAGS) -DTIME_FINDPOLYS -DUSE_GF28 -o $@ $^ $(LDLIBS)
+	$(CXX) -static $(CXXFLAGS) -DTIME_FINDPOLYS -DUSE_GF28 -o $@ $^ $(LDLIBS)
 
 time_findpolys_gf24: rsdecoder.cc FXY.o subset.o subset_iter.o portfolio.o
-	g++ -static $(CXXFLAGS) -DTIME_FINDPOLYS -DUSE_GF24 -o $@ $^ $(LDLIBS)
+	$(CXX) -static $(CXXFLAGS) -DTIME_FINDPOLYS -DUSE_GF24 -o $@ $^ $(LDLIBS)
 
 time_findpolys_w8: rsdecoder.cc FXY.o subset.o subset_iter.o portfolio.o
-	g++ $(CXXFLAGS) -DTIME_FINDPOLYS -DUSE_W8 -o $@ $^ $(LDLIBS)
+	$(CXX) $(CXXFLAGS) -DTIME_FINDPOLYS -DUSE_W8 -o $@ $^ $(LDLIBS)
 
 time_findpolys_w16: rsdecoder.cc FXY.o subset.o subset_iter.o portfolio.o
-	g++ $(CXXFLAGS) -DTIME_FINDPOLYS -DUSE_W16 -o $@ $^ $(LDLIBS)
+	$(CXX) $(CXXFLAGS) -DTIME_FINDPOLYS -DUSE_W16 -o $@ $^ $(LDLIBS)
 
 time_findpolys_w32: rsdecoder.cc FXY.o subset.o subset_iter.o portfolio.o
-	g++ $(CXXFLAGS) -DTIME_FINDPOLYS -DUSE_W32 -o $@ $^ $(LDLIBS)
+	$(CXX) $(CXXFLAGS) -DTIME_FINDPOLYS -DUSE_W32 -o $@ $^ $(LDLIBS)
 
 rr_test: rsdecoder.cc FXY.o gf2e.o
-	g++ $(CXXFLAGS) -DTEST_RR -o $@ $^ $(LDLIBS)
+	$(CXX) $(CXXFLAGS) -DTEST_RR -o $@ $^ $(LDLIBS)
 
 findpolys_test: rsdecoder.cc FXY.o gf2e.o subset_iter.o portfolio.o
-	g++ $(CXXFLAGS) -DTEST_FINDPOLYS -o $@ $^ $(LDLIBS)
+	$(CXX) $(CXXFLAGS) -DTEST_FINDPOLYS -o $@ $^ $(LDLIBS)
 
 testdistserver: testdistserver.cc cmdtools.o
-	g++ -o $@ $^
+	$(CXX) -o $@ $^
 
 agtest: agtest.o libpercyclient.a libpercyserver.a
-	g++ -o $@ $^ $(LDLIBS)
+	$(CXX) -o $@ $^ $(LDLIBS)
 
 hybridtest: hybridtest.o libpercyclient.a libpercyserver.a
-	g++ -o $@ $^ $(LDLIBS)
+	$(CXX) -o $@ $^ $(LDLIBS)
 
 gf2etest: gf2etest.cc gf2e.o
-	g++ $(CXXFLAGS) -o $@ $^ $(LDLIBS)
+	$(CXX) $(CXXFLAGS) -o $@ $^ $(LDLIBS)
+
+cdtest: cdtest.o libpercyclient.a libpercyserver.a
+	$(CXX) -o $@ $^ $(LDLIBS)
 
 .PHONY: docs
 
@@ -157,7 +161,7 @@ dist:
 	tar -czf percy++-$(VERSION).tar.gz --transform 's,^,percy++-$(VERSION)/,' -T releaselist
 
 depend:
-	makedepend -Y -- $(CXXFLAGS) -- $(SRCS) 2>/dev/null
+	makedepend -Y -- $(CXXFLAGS) -- $(SRCS) $(TESTSRCS) 2>/dev/null
 
 # DO NOT DELETE
 
@@ -268,3 +272,11 @@ pirserver_ag.o: gf2e_matrix_impl.h config.h percyio.h
 splitdatabase.o: percyio.h /usr/local/include/NTL/ZZ.h percytypes.h config.h
 splitdatabase.o: version.h gf2e.h
 percyio.o: percyio.h /usr/local/include/NTL/ZZ.h
+cdtest.o: percyserver.h datastore.h /usr/local/include/NTL/ZZ.h percyparams.h
+cdtest.o: version.h percytypes.h percystats.h streams.h gf2e_matrix.h gf2e.h
+cdtest.o: xor.h itserver.h /usr/local/include/NTL/vec_ZZ_p.h itparams.h
+cdtest.o: itserver_impl.h gf2e_matrix_impl.h itclient.h
+cdtest.o: /usr/local/include/NTL/vec_vec_ZZ_p.h
+cdtest.o: /usr/local/include/NTL/vec_GF2E.h percyclient.h percyresult.h
+cdtest.o: percyio.h rsdecoder.h FXY.h portfolio.h recover.h rsdecoder_impl.h
+cdtest.o: subset.h subset_iter.h itclient_impl.h
diff --git a/README b/README
index 5115319..8827e47 100644
--- a/README
+++ b/README
@@ -38,8 +38,8 @@ protocols from the papers:
     2014), July 2014.
 
     Wouter Lueks, Ian Goldberg. "Sublinear Scaling for Multi-Client
-    Private Information Retrieval". CACR Tech Report 2014-19,
-    September 2014.
+    Private Information Retrieval". 19th International Conference on
+    Financial Cryptography and Data Security, January 2015.
 
 
 Briefly, private information retrieval is the task of fetching a block
@@ -211,7 +211,7 @@ Version 1.0 (2014-10-17):
       query.  Use --batch-query option of pirclient.
     - Implemented Strassen's fast matrix multiplication algorithm for
       server computation in Goldberg's IT-PIR protocol (modes GF28,
-      GF216, ZZ_P), based on Lueks and Goldberg (2014).
+      GF216, ZZ_P), based on Lueks and Goldberg (2015).
     - Added statistics collection to the servers and clients.  See usage
       messages of executables for details.
     - Replaced testclient script with runtest and runtestset scripts.
diff --git a/agserver.cc b/agserver.cc
index ed2b048..2b6cc99 100644
--- a/agserver.cc
+++ b/agserver.cc
@@ -52,8 +52,9 @@ PercyAGServer::~PercyAGServer () {}
 
 // Handle a request.  Returns true if successfully completed, and false
 // otherwise.
-bool PercyAGServer::handle_request_impl (std::vector<unsigned char*> requests,
-	std::vector<unsigned char*> responses)
+bool PercyAGServer::handle_request_impl (
+	const std::vector<unsigned char*> &requests,
+	const std::vector<unsigned char*> &responses)
 {
     nqueries_t num_queries = requests.size();
     if (responses.size() != num_queries) {
@@ -317,7 +318,7 @@ bool PercyAGServer::handle_request_20 (unsigned char * request,
 }
 
 void PercyAGServer::combine_results (unsigned char * result, 
-	std::vector<unsigned char*> worker_results)
+	const std::vector<unsigned char*> &worker_results)
 {
     dbsize_t response_size = params->response_size();
     dbsize_t word_size = params->word_size();
@@ -331,7 +332,7 @@ void PercyAGServer::combine_results (unsigned char * result,
     // Add results
     switch (word_size) {
     case 16: {
-	std::vector<unsigned char*>::iterator writ;
+	std::vector<unsigned char*>::const_iterator writ;
 	mask <<= 48;
 	mask -= 1;
 	for (writ = worker_results.begin(); writ != worker_results.end(); ++writ) {
@@ -342,7 +343,7 @@ void PercyAGServer::combine_results (unsigned char * result,
 	}
     } break;
     case 20: {
-	std::vector<unsigned char*>::iterator writ;
+	std::vector<unsigned char*>::const_iterator writ;
 	mask <<= 60;
 	mask -= 1;
 	for (writ = worker_results.begin(); writ != worker_results.end(); ++writ) {
diff --git a/agserver.h b/agserver.h
index cf98f3e..4dee428 100644
--- a/agserver.h
+++ b/agserver.h
@@ -45,11 +45,12 @@ public:
     virtual ~PercyAGServer ();
 
 private:
-    virtual bool handle_request_impl (std::vector<unsigned char*> requests, 
-	    std::vector<unsigned char*> responses);
+    virtual bool handle_request_impl (
+	    const std::vector<unsigned char*> &requests,
+	    const std::vector<unsigned char*> &responses);
 
-    virtual void combine_results (unsigned char * result, 
-	    std::vector<unsigned char*> worker_results);
+    virtual void combine_results (unsigned char * result,
+	    const std::vector<unsigned char*> &worker_results);
 
     const AGParams * params;
     const AG_Element p;
diff --git a/cdtest.cc b/cdtest.cc
new file mode 100644
index 0000000..0b8fbcf
--- /dev/null
+++ b/cdtest.cc
@@ -0,0 +1,100 @@
+// Test constructors, copy constructors, assignment operators, and
+// destructors
+
+#include <vector>
+#include <sstream>
+#include "percyserver.h"
+#include "itclient.h"
+
+template <typename CLI>
+void runtest(const PercyParams *params, size_t NUMSRVS, size_t T)
+{
+    // Create NUMSRVS servers
+    sid_t* server_indices = new sid_t[NUMSRVS];
+    vector<PercyServerParams *> srvparams;
+    vector<DataStore *> datastores;
+    vector<PercyServer *> servers;
+    vector<istream *> istreams;
+    vector<ostream *> ostreams;
+
+    for (size_t i=0; i<NUMSRVS; ++i) {
+	server_indices[i] = i+1;
+	srvparams.push_back(new PercyServerParams(params,
+		server_indices[i], 0, DIST_SPLIT_RECORDS,
+		0, DIST_SPLIT_RECORDS, vector<nservers_t>(), false, false));
+	datastores.push_back(new FileDataStore("database", srvparams[i], 0));
+	servers.push_back(PercyServer::make_server(datastores[i],
+		srvparams[i], NULL));
+	ostreams.push_back(new stringstream());
+    }
+
+    // Create a client
+    PercyClientParams cliparams(params, NUMSRVS);
+    CLI *client = (CLI*) PercyClient::make_client(&cliparams, NUMSRVS,
+	T, server_indices, NULL);
+    CLI c0 = *client, c1 = c0, c2 = c1, c3 = c0, c4 = c2, c5 = c0;
+
+    vector<dbsize_t> blocks;
+    blocks.push_back(1);
+    blocks.push_back(5);
+    blocks.push_back(7);
+    c0.encode_request(blocks);
+    c1 = c0;
+    c1.send_request(1, ostreams);
+
+    for (size_t i=0; i<NUMSRVS; ++i) {
+	stringstream istream(static_cast<stringstream*>(ostreams[i])->str());
+	delete ostreams[i];
+	ostreams[i] = new stringstream();
+	servers[i]->handle_request(istream, *(ostreams[i]));
+	istreams.push_back(new stringstream(
+		static_cast<stringstream*>(ostreams[i])->str()));
+    }
+
+    c2 = c1;
+    c2.receive_replies(1, istreams);
+    c3 = c2;
+    c2.process_replies(NUMSRVS);
+    c3.process_replies(NUMSRVS);
+    c4 = c3;
+    c5 = c2;
+    vector<PercyBlockResults> resblocks4, resblocks5;
+    bool res4 = c4.get_result(1, resblocks4);
+    bool res5 = c5.get_result(1, resblocks5);
+    if (res4 != res5 || resblocks4.size() != resblocks5.size()) {
+	cout << "MISMATCH!\n";
+    }
+    cout << (res4 ? "TRUE" : "FALSE" ) << "\n";
+    size_t numresults = resblocks4.size();
+    for (size_t i = 0; i<numresults; ++i) {
+	resblocks4[i].dump(cout);
+	resblocks5[i].dump(cout);
+    }
+
+    // Clean up
+    delete client;
+
+    for (size_t i=0; i<NUMSRVS; ++i) {
+	delete istreams[i];
+	delete ostreams[i];
+	delete servers[i];
+	delete datastores[i];
+	delete srvparams[i];
+    }
+    srvparams.clear();
+    datastores.clear();
+    servers.clear();
+    istreams.clear();
+    ostreams.clear();
+    delete[] server_indices;
+}
+
+int main(int argc, char **argv)
+{
+    PercyParams *params = NULL;
+
+    params = new GF2EParams(100, 100, 8, 0);
+    runtest<PercyClient_GF2E<GF28_Element> >(params, 3, 1);
+    delete params;
+    return 0;
+}
diff --git a/docs/main.dox b/docs/main.dox
index bdd095b..5ecf3d4 100644
--- a/docs/main.dox
+++ b/docs/main.dox
@@ -50,9 +50,9 @@ href="https://cs.uwaterloo.ca/~iang/pubs/hybridpir-pets.pdf">The Best of Both Wo
     2014), July 2014.</li>
 
 <li>    Wouter Lueks, Ian Goldberg. <a
-href="http://cacr.uwaterloo.ca/techreports/2014/cacr2014-19.pdf">Sublinear Scaling for Multi-Client
-    Private Information Retrieval</a>. CACR Tech Report 2014-19,
-    September 2014.</li>
+href="https://cs.uwaterloo.ca/~iang/pubs/slspir-fc15.pdf">Sublinear Scaling for Multi-Client
+    Private Information Retrieval</a>.  19th International Conference on
+    Financial Cryptography and Data Security, January 2015.</li>
 </ul>
 
 <p>Briefly, private information retrieval is the task of fetching a block
@@ -63,7 +63,7 @@ interested in.</p>
 <p>These protocols provide <b>t-private v-Byzantine-robust &tau;-independent
 k-out-of-l private information retrieval</b>.  This means:</p>
 
-<dd>
+<dl>
 <dt><b>k-out-of-l:</b></dt>
 <dd>there are l distributed database servers, and we only need
             to receive replies from k of them (the rest might be down,
diff --git a/gf2e_matrix.h b/gf2e_matrix.h
index d104d5b..597b946 100644
--- a/gf2e_matrix.h
+++ b/gf2e_matrix.h
@@ -51,10 +51,6 @@ public:
     void is_sum_of(const SubMatrix<const GF2E_Element> &m1,
 	    const SubMatrix<const GF2E_Element> &m2);
     void copy_from(const SubMatrix<const GF2E_Element> &src);
-
-    template <typename GF2E_Element_>
-    friend std::ostream &operator<<(std::ostream &os,
-	    const Matrix<GF2E_Element_> &m);
 };
 
 template <typename GF2E_Element>
@@ -88,10 +84,6 @@ public:
     inline void add_mult_of(
 	    const Col<const GF2E_Element> &col_a,
 	    const Row<const GF2E_Element> &row_b);
-
-    template <typename GF2E_Element_>
-    friend std::ostream &operator<<(std::ostream &os,
-	    const SubMatrix<GF2E_Element_> &m);
 };
 
 template <typename GF2E_Element>
diff --git a/itclient.h b/itclient.h
index bf44be8..b8654c8 100644
--- a/itclient.h
+++ b/itclient.h
@@ -158,9 +158,39 @@ public:
     PercyClient_GF2E (const PercyClientParams * params, nservers_t num_servers,
 	    nservers_t t, sid_t * sids, PercyStats * stats = NULL);
 
+    /// Copy constructor.
+    /// @param other        The instance to copy
+    PercyClient_GF2E (const PercyClient_GF2E &other);
+
+    /// Assignment operator.
+    /// @param rhs          The instance to copy
+    PercyClient_GF2E& operator= (PercyClient_GF2E rhs);
+
     /// Destructor.
     virtual ~PercyClient_GF2E ();
 
+    /// Swapper.
+    /// @param a            The instance to swap
+    /// @param b            The instance to swap it with
+    friend void swap(PercyClient_GF2E &a, PercyClient_GF2E &b) {
+	using std::swap;
+
+	swap((PercyClient&)a, (PercyClient&)b);
+	swap(a.params, b.params);
+	swap(a.indices, b.indices);
+	swap(a.interp_indices, b.interp_indices);
+	swap(a.vec_interp_indices, b.vec_interp_indices);
+	swap(a.vecs_interp_indices, b.vecs_interp_indices);
+	swap(a.indices_ntl, b.indices_ntl);
+	swap(a.randmults, b.randmults);
+	swap(a.stored_shares, b.stored_shares);
+	swap(a.answers, b.answers);
+	swap(a.answers_ntl, b.answers_ntl);
+	swap(a.undecoded_indices, b.undecoded_indices);
+	swap(a.unfinished_results, b.unfinished_results);
+	swap(a.decoded, b.decoded);
+    }
+
 private:
     // Virtual members as described in PercyClient class
     virtual void encode_request_impl (nqueries_t request_identifier);
diff --git a/itclient_impl.h b/itclient_impl.h
index ff525f1..a8bfcb2 100644
--- a/itclient_impl.h
+++ b/itclient_impl.h
@@ -53,7 +53,7 @@ inline void setCoeffs<GF216_Element>(GF2X &GF2X_P) {
     SetCoeff(GF2X_P, 0, 1);
 }
 
-// Constructor and destructor
+// Constructor
 template <typename GF2E_Element>
 PercyClient_GF2E<GF2E_Element>::PercyClient_GF2E (const PercyClientParams * params,
 	nservers_t num_servers, nservers_t t, sid_t * sids, PercyStats * stats) :
@@ -80,6 +80,65 @@ PercyClient_GF2E<GF2E_Element>::PercyClient_GF2E (const PercyClientParams * para
     choose_interp_indices(max_qbs);
 }
 
+// Copy constructor
+template <typename GF2E_Element>
+PercyClient_GF2E<GF2E_Element>::PercyClient_GF2E (
+	const PercyClient_GF2E &other) :
+    PercyClient(other),
+    params(other.params),
+    vec_interp_indices(other.vec_interp_indices),
+    vecs_interp_indices(other.vecs_interp_indices),
+    indices_ntl(other.indices_ntl),
+    randmults(other.randmults),
+    answers_ntl(other.answers_ntl),
+    undecoded_indices(other.undecoded_indices),
+    unfinished_results(other.unfinished_results),
+    decoded(other.decoded)
+{
+    // Deal with indices, interp_indices, stored_shares, answers
+    indices = new GF2E_Element[num_servers];
+    memmove(indices, other.indices, num_servers*sizeof(GF2E_Element));
+
+    nqueries_t qbs = vec_interp_indices.length();
+    interp_indices = new GF2E_Element[qbs];
+    memmove(interp_indices, other.interp_indices, qbs*sizeof(GF2E_Element));
+
+    typename map<nqueries_t, GF2E_Element *>::const_iterator siter;
+    dbsize_t num_virtual_blocks = params->num_virtual_blocks();
+    for (siter = other.stored_shares.begin(); siter != other.stored_shares.end(); ++siter) {
+	nqueries_t qbs = get_qbs(siter->first);
+	const vector<dbsize_t>& block_numbers =
+		get_block_numbers(siter->first);
+	nqueries_t num_block_requests = block_numbers.size();
+	nqueries_t num_queries = (num_block_requests+qbs-1)/qbs;
+	GF2E_Element *shares = new GF2E_Element[num_queries * num_virtual_blocks * num_servers];
+	memmove(shares, siter->second,
+		num_queries * num_virtual_blocks * num_servers *
+		sizeof(GF2E_Element));
+	stored_shares[siter->first] = shares;
+    }
+
+    answers = other.answers;
+    nqueries_t numanswers = answers.size();
+    dbsize_t words_per_block = params->words_per_block();
+    for (nqueries_t i = 0; i < numanswers; ++i) {
+	GF2E_Element *answer = new GF2E_Element[words_per_block * num_servers];
+	memmove(answer, answers[i],
+		words_per_block * num_servers * sizeof(GF2E_Element));
+	answers[i] = answer;
+    }
+}
+
+// Assignment operator
+template <typename GF2E_Element>
+PercyClient_GF2E<GF2E_Element>& PercyClient_GF2E<GF2E_Element>::operator= (
+	PercyClient_GF2E rhs)
+{
+    swap(*this, rhs);
+    return *this;
+}
+
+// Destructor
 template <typename GF2E_Element>
 PercyClient_GF2E<GF2E_Element>::~PercyClient_GF2E ()
 {
@@ -102,7 +161,6 @@ PercyClient_GF2E<GF2E_Element>::~PercyClient_GF2E ()
     stored_shares.clear();
 }
 
-
 // Generate t-private (t+1)-of-l shares of a given secret value.
 template <typename GF2E_Element>
 static void genshares_GF2E(nservers_t t, nservers_t l,
@@ -357,7 +415,8 @@ dbsize_t PercyClient_GF2E<GF2E_Element>::send_request_impl (
     delete[] shares;
     stored_shares.erase(request_identifier);
 
-    return num_servers * num_queries * num_virtual_blocks * sizeof(GF2E_Element);
+    return num_servers * ((send_num_queries ? 2 : 0) + num_queries *
+			    num_virtual_blocks * sizeof(GF2E_Element));
 }
 
 // Receive the server's replies, and return a number of servers that
diff --git a/itserver.cc b/itserver.cc
index 291c1c6..894d028 100644
--- a/itserver.cc
+++ b/itserver.cc
@@ -45,8 +45,9 @@ PercyServer_ZZ_p::~PercyServer_ZZ_p ()
 {}
 
 // TODO: Fix SPIR to match new function call.
-bool PercyServer_ZZ_p::handle_request_impl (std::vector<unsigned char*> requests,
-	std::vector<unsigned char*> responses)
+bool PercyServer_ZZ_p::handle_request_impl (
+	const std::vector<unsigned char*> &requests,
+	const std::vector<unsigned char*> &responses)
 {
     nqueries_t num_queries = requests.size();
     if (responses.size() != num_queries) {
@@ -689,7 +690,7 @@ void PercyServer_ZZ_p::compute_one(const unsigned char * data, ZZ_p * value,
 }
 
 void PercyServer_ZZ_p::combine_results (unsigned char * result, 
-	std::vector<unsigned char*> worker_results)
+	const std::vector<unsigned char*> &worker_results)
 {
     nservers_t num_workers = worker_results.size();
     dbsize_t word_bytes = params->modulus_bytes();
@@ -721,8 +722,9 @@ PercyServer_Chor::PercyServer_Chor (DataStore * datastore,
 PercyServer_Chor::~PercyServer_Chor ()
 {}
 
-bool PercyServer_Chor::handle_request_impl (std::vector<unsigned char*> requests,
-	std::vector<unsigned char*> responses)
+bool PercyServer_Chor::handle_request_impl (
+	const std::vector<unsigned char*> &requests,
+	const std::vector<unsigned char*> &responses)
 {
     nqueries_t num_queries = requests.size();
     if (responses.size() != num_queries) {
@@ -803,7 +805,7 @@ bool PercyServer_Chor::handle_request_impl (std::vector<unsigned char*> requests
 }
 
 void PercyServer_Chor::combine_results (unsigned char * result, 
-	std::vector<unsigned char*> worker_results)
+	const std::vector<unsigned char*> &worker_results)
 {
     dbsize_t block_size = params->block_size() * params->virtual_block_size();
     for (nservers_t i = 0; i < worker_results.size(); ++i) {
diff --git a/itserver.h b/itserver.h
index 64490c9..3960147 100644
--- a/itserver.h
+++ b/itserver.h
@@ -54,11 +54,12 @@ public:
     virtual ~PercyServer_ZZ_p ();
 
 private:
-    virtual bool handle_request_impl (std::vector<unsigned char*> requests, 
-	    std::vector<unsigned char*> responses);
+    virtual bool handle_request_impl (
+	    const std::vector<unsigned char*> &requests,
+	    const std::vector<unsigned char*> &responses);
 
-    virtual void combine_results (unsigned char * result, 
-	    std::vector<unsigned char*> worker_results);
+    virtual void combine_results (unsigned char * result,
+	    const std::vector<unsigned char*> &worker_results);
 
     const ZZ_pParams * params;
 
@@ -115,11 +116,12 @@ public:
     virtual ~PercyServer_Chor ();
 
 private:
-    virtual bool handle_request_impl (std::vector<unsigned char*> requests, 
-	    std::vector<unsigned char*> responses);
+    virtual bool handle_request_impl (
+	    const std::vector<unsigned char*> &requests,
+	    const std::vector<unsigned char*> &responses);
 
-    virtual void combine_results (unsigned char * result, 
-	    std::vector<unsigned char*> worker_results);
+    virtual void combine_results (unsigned char * result,
+	    const std::vector<unsigned char*> &worker_results);
 
     const ChorParams * params;
 };
@@ -172,11 +174,12 @@ private:
 
     nqueries_t strassen_real_max_depth;
 
-    virtual bool handle_request_impl (std::vector<unsigned char*> requests, 
-	    std::vector<unsigned char*> responses);
+    virtual bool handle_request_impl (
+	    const std::vector<unsigned char*> &requests,
+	    const std::vector<unsigned char*> &responses);
 
-    virtual void combine_results (unsigned char * result, 
-	    std::vector<unsigned char*> worker_results);
+    virtual void combine_results (unsigned char * result,
+	    const std::vector<unsigned char*> &worker_results);
 
     const GF2EParams * params;
 };
diff --git a/itserver_impl.h b/itserver_impl.h
index f1a798d..5ce3a45 100644
--- a/itserver_impl.h
+++ b/itserver_impl.h
@@ -675,8 +675,8 @@ nqueries_t PercyServer_GF2E<GF2E_Element>::optimal_strassen_num_queries(nqueries
 
 template <typename GF2E_Element>
 bool PercyServer_GF2E<GF2E_Element>::handle_request_impl (
-	std::vector<unsigned char*> requests, 
-	std::vector<unsigned char*> responses)
+	const std::vector<unsigned char*> &requests,
+	const std::vector<unsigned char*> &responses)
 {
     nqueries_t num_queries = requests.size();
     if (responses.size() != num_queries) {
@@ -783,7 +783,7 @@ bool PercyServer_GF2E<GF2E_Element>::handle_request_impl (
 
 template <typename GF2E_Element>
 void PercyServer_GF2E<GF2E_Element>::combine_results (unsigned char * result, 
-	std::vector<unsigned char*> worker_results)
+	const std::vector<unsigned char*> &worker_results)
 {
     dbsize_t block_size = params->block_size() * params->virtual_block_size();
     for (nservers_t i = 0; i < worker_results.size(); ++i) {
diff --git a/percyclient.h b/percyclient.h
index 8de97e9..f80ccfa 100644
--- a/percyclient.h
+++ b/percyclient.h
@@ -116,6 +116,27 @@ public:
 	    vector<istream*> &isvec, vector<PercyBlockResults> &results, 
 	    nqueries_t querybsize = 1);
 
+    /// Swapper.
+    /// @param a            The instance to swap
+    /// @param b            The instance to swap it with
+    friend void swap(PercyClient &a, PercyClient &b) {
+	using std::swap;
+
+	swap(a.clientparams, b.clientparams);
+	swap(a.num_servers, b.num_servers);
+	swap(a.t, b.t);
+	swap(a.goodservers, b.goodservers);
+	swap(a.next_request_identifier, b.next_request_identifier);
+	swap(a.requested_blocks, b.requested_blocks);
+	swap(a.blocks_per_query, b.blocks_per_query);
+	swap(a.statuses, b.statuses);
+	swap(a.undecoded_blocks, b.undecoded_blocks);
+	swap(a.decoded_blocks, b.decoded_blocks);
+	swap(a.stats, b.stats);
+	swap(a.request_id_to_stats_batch_number,
+		b.request_id_to_stats_batch_number);
+    }
+
 protected:
     friend class RecursiveClient;
 
diff --git a/percyserver.cc b/percyserver.cc
index 1e9e04a..468a4ab 100644
--- a/percyserver.cc
+++ b/percyserver.cc
@@ -47,7 +47,8 @@ PercyServer::PercyServer (DataStore * datastore,
     datastore(datastore),
     serverparams(serverparams),
     stats(stats),
-    strassen_max_depth(PercyServer::STRASSEN_OPTIMAL)
+    strassen_max_depth(PercyServer::STRASSEN_OPTIMAL),
+    strassen_level_reached(0)
 {
     if (serverparams->is_threaded() && !(serverparams->is_recursive())) {
 	nservers_t num_threads = serverparams->num_threads();
@@ -111,6 +112,12 @@ void PercyServer::be_byzantine ()
 void PercyServer::set_strassen_max_depth (nqueries_t depth)
 {
     strassen_max_depth = depth;
+    if (serverparams->is_threaded() && !(serverparams->is_recursive())) {
+	nservers_t num_subservers = subservers.size();
+	for (nservers_t i = 0; i < num_subservers; ++i) {
+	    subservers[i]->set_strassen_max_depth(depth);
+	}
+    }
 }
 
 nqueries_t PercyServer::get_strassen_max_depth ()
@@ -118,60 +125,89 @@ nqueries_t PercyServer::get_strassen_max_depth ()
     return strassen_max_depth;
 }
 
-// Handle a request.
+// Handle a request from a single client
 bool PercyServer::handle_request(istream &is, ostream &os, 
-	std::vector<std::iostream*> workers)
+	const std::vector<std::iostream*> &workers)
+{
+    std::vector<std::istream *> isv(1, &is);
+    std::vector<std::ostream *> osv(1, &os);
+
+    return handle_request(isv, osv, workers);
+}
+
+// Handle a request from a number of clients simultaneously
+bool PercyServer::handle_request (const std::vector<std::istream *> &isv,
+				  const std::vector<std::ostream *> &osv,
+				  const std::vector<std::iostream*> &workers)
 {
-    // Read number of queries
-    nqueries_t num_queries;
-    percy_read_le_uint16(is, num_queries);
-    if (is.eof() || num_queries == 0) {
+    size_t num_clients = isv.size();
+    if (num_clients != osv.size()) {
 	return false;
     }
 
+    // Read number of queries from each client
+    vector<nqueries_t> num_queries_vec;
+    nqueries_t tot_num_queries = 0;
+    for (size_t c=0; c<num_clients; ++c) {
+	nqueries_t client_num_queries;
+	percy_read_le_uint16(*(isv[c]), client_num_queries);
+	if (isv[c]->eof()) {
+	    client_num_queries = 0;
+	}
+	num_queries_vec.push_back(client_num_queries);
+	tot_num_queries += client_num_queries;
+    }
+
     // Not distributed
     nqueries_t batch_number = 0;
     if (stats) {
-	batch_number = stats->start_query_batch(num_queries);
+	batch_number = stats->start_query_batch(tot_num_queries);
 	stats->client_to_server_start(batch_number);
     }
 
-    // Read request
+    // Read requests
     const PercyParams * params = serverparams->percy_params();
     dbsize_t query_request_size = params->request_size();
-    dbsize_t request_size = num_queries * query_request_size;
-    unsigned char * request = new unsigned char[request_size];
-    // read in chunks to compensate for bug in socket++
-    dbsize_t read_chunks = request_size / READ_SIZE;
-    dbsize_t read_leftover = request_size % READ_SIZE;
-    for (dbsize_t i = 0; i < read_chunks; ++i) {
-	is.read((char*)request + i * READ_SIZE, READ_SIZE);
-    }
-    if (read_leftover > 0) {
-	is.read((char*)request + read_chunks * READ_SIZE, read_leftover);
-    }
-    if (is.eof()) {
-	std::cerr << "Request not large enough.\n";
-	if (stats) {
-	    stats->decode_done(batch_number, num_queries);
-	    stats->finish_query_batch(batch_number);
+    dbsize_t tot_request_size = tot_num_queries * query_request_size;
+    unsigned char * request = new unsigned char[tot_request_size];
+    char * request_readptr = (char *) request;
+    for (size_t c=0; c<num_clients; ++c) {
+	// read in chunks to compensate for bug in socket++
+	dbsize_t client_request_size = num_queries_vec[c] *
+					query_request_size;
+	dbsize_t read_chunks = client_request_size / READ_SIZE;
+	dbsize_t read_leftover = client_request_size % READ_SIZE;
+	for (dbsize_t i = 0; i < read_chunks; ++i) {
+	    isv[c]->read(request_readptr, READ_SIZE);
+	    request_readptr += READ_SIZE;
+	}
+	if (read_leftover > 0) {
+	    isv[c]->read(request_readptr, read_leftover);
+	    request_readptr += read_leftover;
+	}
+	if (isv[c]->eof()) {
+	    std::cerr << "Request not large enough.\n";
+	    if (stats) {
+		stats->decode_done(batch_number, tot_num_queries);
+		stats->finish_query_batch(batch_number);
+	    }
+	    delete[] request;
+	    return false;
 	}
-	delete[] request;
-	return false;
     }
 
     if (stats) {
-	stats->client_to_server_done(batch_number, request_size);
+	stats->client_to_server_done(batch_number, tot_request_size);
     }
 
     // Run the correct implementation functions
     dbsize_t query_response_size = params->response_size();
-    dbsize_t response_size = num_queries * query_response_size;
-    unsigned char * response = new unsigned char[response_size];
-    memset(response, 0, response_size);
+    dbsize_t tot_response_size = tot_num_queries * query_response_size;
+    unsigned char * response = new unsigned char[tot_response_size];
+    memset(response, 0, tot_response_size);
 
     std::vector<unsigned char*> requests, responses;
-    for (nqueries_t q = 0; q < num_queries; ++q) {
+    for (nqueries_t q = 0; q < tot_num_queries; ++q) {
 	requests.push_back(request + q * query_request_size);
 	responses.push_back(response + q * query_response_size);
     }
@@ -189,13 +225,19 @@ bool PercyServer::handle_request(istream &is, ostream &os,
 	stats->server_to_client_start(batch_number);
     }
 
-    // Send response
-    os.write((char*)response, response_size);
-    os.flush();
+    // Send responses
+    char *response_writeptr = (char *)response;
+    for (size_t c=0; c<num_clients; ++c) {
+	dbsize_t client_response_size = num_queries_vec[c] *
+					query_response_size;
+	osv[c]->write(response_writeptr, client_response_size);
+	osv[c]->flush();
+	response_writeptr += client_response_size;
+    }
 
     if (stats) {
-	stats->server_to_client_done(batch_number, response_size);
-	stats->decode_done(batch_number, ( ret ? 0 : num_queries ));
+	stats->server_to_client_done(batch_number, tot_response_size);
+	stats->decode_done(batch_number, ( ret ? 0 : tot_num_queries ));
 	stats->strassen_level_reached(batch_number,
 		strassen_level_reached);
 	stats->finish_query_batch(batch_number);
@@ -260,8 +302,9 @@ static void close_highfds_except(int exceptfd)
     }
 }
 
-bool PercyServer::handle_request_threaded (std::vector<unsigned char*> requests,
-	std::vector<unsigned char*> responses)
+bool PercyServer::handle_request_threaded (
+	const std::vector<unsigned char*> &requests,
+	const std::vector<unsigned char*> &responses)
 {
     nqueries_t num_queries = requests.size();
     if (responses.size() != requests.size()) {
@@ -553,6 +596,15 @@ bool PercyServer::handle_request_threaded (std::vector<unsigned char*> requests,
 		}
 	    }
 	}
+
+	// Log maximum strassen depth of subservers
+	for (nservers_t i = 0; i < num_threads; ++i) {
+	    nqueries_t subserver_strassen_level_reached = subservers[i]->strassen_level_reached;
+	    if (subserver_strassen_level_reached > strassen_level_reached) {
+		strassen_level_reached = subserver_strassen_level_reached;
+	    }
+	}
+
     }
 
     if (intermediate) delete[] intermediate;
@@ -567,8 +619,10 @@ bool PercyServer::handle_request_threaded (std::vector<unsigned char*> requests,
 }
 
 // Do distributed computation
-bool PercyServer::handle_request_distributed (std::vector<unsigned char*> requests, 
-	std::vector<unsigned char*> responses, std::vector<std::iostream*> workers)
+bool PercyServer::handle_request_distributed (
+	const std::vector<unsigned char*> &requests,
+	const std::vector<unsigned char*> &responses,
+	const std::vector<std::iostream*> &workers)
 {
     nqueries_t num_queries = requests.size();
     if (responses.size() != num_queries) {
diff --git a/percyserver.h b/percyserver.h
index 1da0ca5..42646af 100644
--- a/percyserver.h
+++ b/percyserver.h
@@ -60,14 +60,26 @@ public:
     /// @return	    The strassen max level being used.
     nqueries_t get_strassen_max_depth();
 
-    /// Handle a request.
+    /// Handle a request from a single client.
     /// @param is	Input stream from the client.
     /// @param os	Output stream to the client.
-    /// @param workers	When the server is a master server, a list of 
+    /// @param workers	When the server is a master server, a list of
     ///			input/output streams to/from the workers.
     /// @return		Returns false if there is an error, true otherwise.
     virtual bool handle_request (std::istream &is, std::ostream &os,
-	    std::vector<std::iostream*> workers = std::vector<std::iostream*>());
+				 const std::vector<std::iostream*> &workers =
+				    std::vector<std::iostream*>());
+
+    /// Handle a request from a number of clients simultaneously.
+    /// @param isv	Input vector of streams from the clients.
+    /// @param osv	Output vector of streams to the clients.
+    /// @param workers	When the server is a master server, a list of
+    ///			input/output streams to/from the workers.
+    /// @return		Returns false if there is an error, true otherwise.
+    virtual bool handle_request (const std::vector<std::istream *> &isv,
+				 const std::vector<std::ostream *> &osv,
+				 const std::vector<std::iostream*> &workers =
+				    std::vector<std::iostream*>());
 
 protected:
     friend class RecursiveServer;
@@ -78,8 +90,9 @@ protected:
     /// @param requests	    A set of query requests, one for each query.
     /// @param responses    Buffers that must be filled with the query responses.
     /// @return		    Returns false is there is an error, true otherwise.
-    virtual bool handle_request_impl (std::vector<unsigned char*> requests, 
-	    std::vector<unsigned char*> responses) = 0;
+    virtual bool handle_request_impl (
+	    const std::vector<unsigned char*> &requests,
+	    const std::vector<unsigned char*> &responses) = 0;
 
     /// Implementation of handle_request() used for master servers.  Must be
     /// implemented in derived classes.
@@ -88,17 +101,19 @@ protected:
     /// @param workers	    When the server is a master server, a list of 
     ///			    input/output streams to/from the workers.
     /// @return		    Returns false is there is an error, true otherwise.
-    virtual bool handle_request_distributed (std::vector<unsigned char*> requests,
-	    std::vector<unsigned char*> responses, 
-	    std::vector<std::iostream*> workers);
+    virtual bool handle_request_distributed (
+	    const std::vector<unsigned char*> &requests,
+	    const std::vector<unsigned char*> &responses,
+	    const std::vector<std::iostream*> &workers);
 
     /// Implementation of handle_request() to be used when using multithreading.  
     /// Must be implemented in derived classes.
     /// @param requests	    A set of query requests, one for each query.
     /// @param responses    Buffers that must be filled with the query responses.
     /// @return		    Returns false is there is an error, true otherwise.
-    virtual bool handle_request_threaded (std::vector<unsigned char*> requests,
-	    std::vector<unsigned char*> responses);
+    virtual bool handle_request_threaded (
+	    const std::vector<unsigned char*> &requests,
+	    const std::vector<unsigned char*> &responses);
 
     /// Combines the results of threads/workers when partitioning database
     /// records (DIST_SPLIT_RECORDS).
@@ -106,7 +121,7 @@ protected:
     /// @param worker_results	The results from all threads/workers to be 
     ///				combined.
     virtual void combine_results (unsigned char * result, 
-	    std::vector<unsigned char*> worker_results) = 0;
+	    const std::vector<unsigned char*> &worker_results) = 0;
 
     /// Constructor.  Can only be called by derived classes.
     /// @param datastore    Database the server will use.
@@ -138,6 +153,12 @@ protected:
     template <typename GF2E_Element> class Row;
     template <typename GF2E_Element> class Elem;
 
+    template <typename GF2E_Element_>
+    friend std::ostream &operator<<(std::ostream &os,
+                const Matrix<GF2E_Element_> &m);
+    template <typename GF2E_Element_>
+    friend std::ostream &operator<<(std::ostream &os,
+                const SubMatrix<GF2E_Element_> &m);
 };
 
 std::vector<nqueries_t> split_queries (nqueries_t num_queries, 
diff --git a/recursiveparams.h b/recursiveparams.h
index 67a85b1..76f8333 100644
--- a/recursiveparams.h
+++ b/recursiveparams.h
@@ -49,7 +49,7 @@ public:
 
     // Prints the mode-specfic paramaters.  Meant to be overloaded by
     // mode-specific classes
-    virtual void print_mode_specific (std::ostream& os, char sep = ',') const {}
+    virtual void print_mode_specific (std::ostream& os) const {}
 
     // For use in distributed computation.
     virtual std::vector<const PercyParams*> create_worker_params (
diff --git a/recursiveserver.cc b/recursiveserver.cc
index 7bd7d29..b677734 100644
--- a/recursiveserver.cc
+++ b/recursiveserver.cc
@@ -83,7 +83,7 @@ RecursiveServer::~RecursiveServer ()
 }
 
 bool RecursiveServer::handle_request (std::istream &is, std::ostream &os,
-	std::vector<std::iostream*> workers)
+	const std::vector<std::iostream*> &workers)
 {
     if (serverparams->is_worker()) {
 	return handle_request_worker(is, os);
@@ -91,8 +91,9 @@ bool RecursiveServer::handle_request (std::istream &is, std::ostream &os,
     return PercyServer::handle_request(is, os, workers);
 }
 
-bool RecursiveServer::handle_request_impl (std::vector<unsigned char*> requests, 
-	std::vector<unsigned char*> responses)
+bool RecursiveServer::handle_request_impl (
+	const std::vector<unsigned char*> &requests,
+	const std::vector<unsigned char*> &responses)
 {
     nqueries_t num_queries = requests.size();
     if (responses.size() != num_queries) {
@@ -148,8 +149,9 @@ bool RecursiveServer::handle_request_impl (std::vector<unsigned char*> requests,
     return good;
 }
 
-bool RecursiveServer::handle_request_threaded (std::vector<unsigned char*> requests, 
-	std::vector<unsigned char*> responses)
+bool RecursiveServer::handle_request_threaded (
+	const std::vector<unsigned char*> &requests,
+	const std::vector<unsigned char*> &responses)
 {
     if (serverparams->thread_split() == DIST_SPLIT_QUERIES) {
 	return PercyServer::handle_request_threaded(requests, responses);
@@ -209,8 +211,10 @@ bool RecursiveServer::handle_request_threaded (std::vector<unsigned char*> reque
     return good;
 }
 
-bool RecursiveServer::handle_request_distributed (std::vector<unsigned char*> requests, 
-	std::vector<unsigned char*> responses, std::vector<std::iostream*> workers)
+bool RecursiveServer::handle_request_distributed (
+	const std::vector<unsigned char*> &requests,
+	const std::vector<unsigned char*> &responses,
+	const std::vector<std::iostream*> &workers)
 {
     if (serverparams->worker_split() == DIST_SPLIT_QUERIES) {
 	return PercyServer::handle_request_distributed(requests, responses, workers);
@@ -414,6 +418,6 @@ bool RecursiveServer::handle_request_worker (std::istream& is, std::ostream& os)
 */
 
 void RecursiveServer::combine_results (unsigned char * result, 
-	std::vector<unsigned char*> worker_results)
+	const std::vector<unsigned char*> &worker_results)
 {}
 
diff --git a/recursiveserver.h b/recursiveserver.h
index 0e77e1c..da7da41 100644
--- a/recursiveserver.h
+++ b/recursiveserver.h
@@ -42,21 +42,25 @@ public:
     virtual ~RecursiveServer ();
 
     virtual bool handle_request (std::istream &is, std::ostream &os,
-	    std::vector<std::iostream*> workers = std::vector<std::iostream*>());
+	    const std::vector<std::iostream*> &workers =
+		std::vector<std::iostream*>());
 
 private:
-    virtual bool handle_request_impl (std::vector<unsigned char*> requests, 
-	    std::vector<unsigned char*> responses);
+    virtual bool handle_request_impl (
+	    const std::vector<unsigned char*> &requests,
+	    const std::vector<unsigned char*> &responses);
 
-    virtual bool handle_request_distributed (std::vector<unsigned char*> requests, 
-	    std::vector<unsigned char*> responses, 
-	    std::vector<std::iostream*> workers);
+    virtual bool handle_request_distributed (
+	    const std::vector<unsigned char*> &requests,
+	    const std::vector<unsigned char*> &responses,
+	    const std::vector<std::iostream*> &workers);
 
-    virtual bool handle_request_threaded (std::vector<unsigned char*> requests, 
-	    std::vector<unsigned char*> responses);
+    virtual bool handle_request_threaded (
+	    const std::vector<unsigned char*> &requests,
+	    const std::vector<unsigned char*> &responses);
 
-    virtual void combine_results (unsigned char * result, 
-	    std::vector<unsigned char*> worker_results);
+    virtual void combine_results (unsigned char * result,
+	    const std::vector<unsigned char*> &worker_results);
 
     const RecursiveServerParams * serverparams;
     const RecursiveParams * params;
diff --git a/streams.cc b/streams.cc
index 9a95ef0..74ed542 100644
--- a/streams.cc
+++ b/streams.cc
@@ -142,7 +142,7 @@ std::streamsize MemoryStreamBuf::showmanyc ()
     std::streamsize total = 0;
     BufferList::iterator iter;
     for (iter = inbuffers.begin(); iter != inbuffers.end(); ++iter) {
-	total += ( iter->size < 0 ? 0 : iter->size );
+	total += ( iter->size <= 0 ? 0 : iter->size );
     }
     return total;
 }
